import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import fs from "fs";
import path from "path";
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const banner =
`/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = (process.argv[2] === 'production');

// Plugin to resolve @quartermaster/core path alias
const pathAliasPlugin = {
	name: 'path-alias',
	setup(build) {
		build.onResolve({ filter: /^@quartermaster\/core\// }, args => {
			// Remove the @quartermaster/core/ prefix and replace with actual path
			const subpath = args.path.replace(/^@quartermaster\/core\//, '');
			const resolvedPath = path.resolve(__dirname, '../core', subpath + '.ts');
			return { path: resolvedPath };
		});
	}
};

// Plugin to copy YAML config files and other assets
const copyAssetsPlugin = {
	name: 'copy-assets',
	setup(build) {
		build.onEnd(() => {
			const configDir = path.join('..', '..', 'config');
			const outDir = build.initialOptions.outdir || path.dirname(build.initialOptions.outfile);

			// Create output directory if needed
			if (!fs.existsSync(outDir) && outDir !== '.') {
				fs.mkdirSync(outDir, { recursive: true });
			}

			// Create config subdirectory in output
			const configOutDir = path.join(outDir, 'config');
			if (!fs.existsSync(configOutDir)) {
				fs.mkdirSync(configOutDir, { recursive: true });
			}

			// Copy YAML files to config subdirectory
			fs.readdirSync(configDir).forEach(file => {
				if (file.endsWith('.yaml')) {
					const srcPath = path.join(configDir, file);
					const destPath = path.join(configOutDir, file);
					fs.copyFileSync(srcPath, destPath);
				}
			});

			// Create and copy templates subdirectory
			const templatesDir = path.join(configDir, 'templates');
			const templatesOutDir = path.join(configOutDir, 'templates');

			if (fs.existsSync(templatesDir)) {
				if (!fs.existsSync(templatesOutDir)) {
					fs.mkdirSync(templatesOutDir, { recursive: true });
				}

				// Copy all template files
				fs.readdirSync(templatesDir).forEach(file => {
					if (file.endsWith('.yaml')) {
						const srcPath = path.join(templatesDir, file);
						const destPath = path.join(templatesOutDir, file);
						fs.copyFileSync(srcPath, destPath);
					}
				});
			} else {
				// Create empty templates directory in output
				if (!fs.existsSync(templatesOutDir)) {
					fs.mkdirSync(templatesOutDir, { recursive: true });
				}
			}

			// Copy manifest.json and styles.css to dist
			const manifestSrc = 'manifest.json';
			const manifestDest = path.join(outDir, 'manifest.json');
			if (fs.existsSync(manifestSrc)) {
				fs.copyFileSync(manifestSrc, manifestDest);
			}

			const stylesSrc = 'styles.css';
			const stylesDest = path.join(outDir, 'styles.css');
			if (fs.existsSync(stylesSrc)) {
				fs.copyFileSync(stylesSrc, stylesDest);
			}
		});
	}
};

const context = await esbuild.context({
	banner: {
		js: banner,
	},
	entryPoints: ['src/main.ts'],
	bundle: true,
	external: [
		'obsidian',
		'electron',
		'@codemirror/autocomplete',
		'@codemirror/collab',
		'@codemirror/commands',
		'@codemirror/language',
		'@codemirror/lint',
		'@codemirror/search',
		'@codemirror/state',
		'@codemirror/view',
		'@lezer/common',
		'@lezer/highlight',
		'@lezer/lr',
		...builtins
	],
	format: 'cjs',
	target: 'es2018',
	logLevel: "info",
	sourcemap: prod ? false : 'inline',
	treeShaking: true,
	outfile: 'dist/main.js',
	plugins: [pathAliasPlugin, copyAssetsPlugin],
});

if (prod) {
	await context.rebuild();
	process.exit(0);
} else {
	await context.watch();
}
